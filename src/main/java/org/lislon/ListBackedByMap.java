package org.lislon;

import com.google.common.collect.ForwardingList;

import java.util.*;
import java.util.function.Function;

/**
 * A List which is backed by a {@link Map}, i.e. modification on the
 * list will propagate changes to underlying map.
 * <p>
 * Keys of the map are generated by user-provided
 * {@code valueToKeyMapper} {@link Function}, which accepts list value
 * and returns key.

 * Notes:
 * <ul>
 *  <li>The underlying map doesn't preserve any order of a list.</li>
 *  <li>Values allowed to be {@code null}, but mapper function should return non-null keys for these</li>
 *  <li>Class is not thread-safe.</li>
 * </ul>
 *
 * @author Igor Avdeev
 * @param <K> Type of backed map key
 * @param <V> Type of backed map value
 */
public class ListBackedByMap<K, V> extends ForwardingList<V> {

    private Function<V, K> valueToKeyMapper;
    private Map<K, V> backedMap;
    private List<V> delegateList;

    public ListBackedByMap(Function<V, K> valueToKeyMapper) {
        this(valueToKeyMapper, new HashMap<>());
    }

    /**
     * Creates a List initialized with {@link Map} values.
     *
     * @param valueToKeyMapper Function accepting {@link List} value and
     *                         returning key for this value to be saved in map.
     * @param initialMap       Initial values of the map, which will be copied to internal map.
     */
    public ListBackedByMap(Function<V, K> valueToKeyMapper, Map<K, V> initialMap) {
        this.backedMap = new HashMap<>(initialMap);
        this.valueToKeyMapper = valueToKeyMapper;
        this.delegateList = new ArrayList<>();
    }


    /**
     * Returns unmodifiable {@link Map} which will hold the values of underlying list.
     * <p>
     * This map can be mutated only by {@link ListBackedByMap}, when modification of list occurs.
     *
     * @return unmodifiable backed map.
     */
    public Map<K, V> getBackedMap() {
        return Collections.unmodifiableMap(backedMap);
    }

    @Override
    public void add(int index, V element) {
        K key = keyByVal(element);
        // prevent adding duplicates to a list
        if (!backedMap.containsKey(key)) {
            super.add(index, element);
            backedMap.put(key, element);
        }
    }

    @Override
    public ListIterator<V> listIterator() {
        return standardListIterator();
    }

    @Override
    public ListIterator<V> listIterator(int index) {
        return standardListIterator(index);
    }

    @Override
    public Iterator<V> iterator() {
        return standardIterator();
    }

    @Override
    public boolean addAll(int index, Collection<? extends V> elements) {
        return standardAddAll(index, elements);
    }

    @Override
    public boolean remove(Object object) {
        return standardRemove(object);
    }

    @Override
    public V remove(int index) {
        V value = super.remove(index);
        backedMap.remove(keyByVal(value));
        return value;
    }

    @Override
    public V set(int index, V element) {
        V value = super.set(index, element);
        backedMap.put(keyByVal(value), element);
        return value;
    }

    @Override
    public boolean removeAll(Collection<?> collection) {
        return standardRemoveAll(collection);
    }

    @Override
    public boolean add(V element) {
        return standardAdd(element);
    }

    @Override
    public boolean addAll(Collection<? extends V> collection) {
        return standardAddAll(collection);
    }

    @Override
    public boolean retainAll(Collection<?> collection) {
        return standardRetainAll(collection);
    }

    @Override
    public void clear() {
        standardClear();
    }

    @Override
    public List<V> subList(int fromIndex, int toIndex) {
        return standardSubList(fromIndex, toIndex);
    }

    @Override
    protected List<V> delegate() {
        return delegateList;
    }

    private K keyByVal(V value) {
        return valueToKeyMapper.apply(value);
    }
}
